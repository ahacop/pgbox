package render

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/ahacop/pgbox/internal/model"
)

// RenderInitSQL renders init.sql from the model
func RenderInitSQL(m *model.InitModel, outputPath string) error {
	initPath := filepath.Join(outputPath, "init.sql")

	// Parse existing file to get any user content
	existingBlocks, preContent, err := ParseInitSQLAnchors(initPath)
	if err != nil {
		return fmt.Errorf("failed to parse existing init.sql: %w", err)
	}

	// Build the new content
	var lines []string

	// Add any pre-existing content (user content before anchors)
	if len(preContent) > 0 {
		lines = append(lines, preContent...)
		if len(preContent) > 0 && preContent[len(preContent)-1] != "" {
			lines = append(lines, "") // Add blank line separator
		}
	}

	// Add header if this is a new file
	if len(existingBlocks) == 0 && len(preContent) == 0 {
		lines = append(lines,
			"-- PostgreSQL initialization script",
			"-- Generated by pgbox",
			"",
		)
	}

	// Add fragments with anchors
	fragments := m.GetOrderedFragments()
	for _, frag := range fragments {
		// Start anchor with hash
		lines = append(lines, fmt.Sprintf("-- pgbox: begin %s sha256=%s", frag.Name, frag.SHA256[:16]))

		// Add the SQL content
		contentLines := strings.Split(strings.TrimSpace(frag.Content), "\n")
		lines = append(lines, contentLines...)

		// End anchor
		lines = append(lines, fmt.Sprintf("-- pgbox: end %s", frag.Name))
		lines = append(lines, "") // Blank line between fragments
	}

	// Add any existing blocks that weren't replaced
	// This preserves user-added fragments that aren't managed by pgbox
	for name, content := range existingBlocks {
		found := false
		for _, frag := range fragments {
			if frag.Name == name {
				found = true
				break
			}
		}
		if !found {
			// Preserve this user block
			lines = append(lines, fmt.Sprintf("-- pgbox: begin %s", name))
			lines = append(lines, content...)
			lines = append(lines, fmt.Sprintf("-- pgbox: end %s", name))
			lines = append(lines, "")
		}
	}

	// Write the file
	return WriteLines(initPath, lines)
}

// RenderPostgreSQLConf renders a postgresql.conf snippet or ALTER SYSTEM commands
func RenderPostgreSQLConf(pgConf *model.PGConfModel, outputPath string) error {
	if pgConf == nil || (len(pgConf.SharedPreload) == 0 && len(pgConf.GUCs) == 0) {
		// Nothing to configure
		return nil
	}

	confPath := filepath.Join(outputPath, "postgresql.conf.pgbox")

	var lines []string
	lines = append(lines,
		"# PostgreSQL configuration generated by pgbox",
		"# Add these settings to postgresql.conf or use ALTER SYSTEM",
		"",
	)

	// Add shared_preload_libraries if set
	if len(pgConf.SharedPreload) > 0 {
		preloadStr := pgConf.GetSharedPreloadString()
		lines = append(lines, fmt.Sprintf("shared_preload_libraries = '%s'", preloadStr))
	}

	// Add other GUCs
	for key, value := range pgConf.GUCs {
		// Quote the value if it contains spaces or special characters
		quotedValue := value
		if strings.ContainsAny(value, " ,='\"") && !strings.HasPrefix(value, "'") {
			quotedValue = fmt.Sprintf("'%s'", value)
		}
		lines = append(lines, fmt.Sprintf("%s = %s", key, quotedValue))
	}

	lines = append(lines, "")

	// Also generate ALTER SYSTEM commands as an alternative
	lines = append(lines,
		"-- Alternatively, use these ALTER SYSTEM commands:",
		"-- Connect to PostgreSQL and run:",
		"",
	)

	if len(pgConf.SharedPreload) > 0 {
		preloadStr := pgConf.GetSharedPreloadString()
		lines = append(lines, fmt.Sprintf("-- ALTER SYSTEM SET shared_preload_libraries = '%s';", preloadStr))
	}

	for key, value := range pgConf.GUCs {
		lines = append(lines, fmt.Sprintf("-- ALTER SYSTEM SET %s = '%s';", key, value))
	}

	if pgConf.RequireRestart {
		lines = append(lines,
			"",
			"-- Note: These changes require a PostgreSQL restart to take effect",
			"-- Run: SELECT pg_reload_conf(); for non-restart settings",
			"-- Or restart the container for shared_preload_libraries changes",
		)
	}

	return WriteLines(confPath, lines)
}